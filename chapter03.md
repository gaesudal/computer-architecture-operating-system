## 3.1 소스 코드와 명령어

- high level programming language : 사람을 위한 언어
- low level programming language : 컴퓨터가 이해하고 실행할 수 있느 언어
    - 기계어 : 0과 1의 명령어 비트로 이루어진 언어
    - 어셈블리어 : 0과 1로 표현된 명령어를 읽기 편한 형태로 번역한 언어

고급 언어가 저급 언어로 변환되는 방식

- 컴파일 : 컴파일러를 통하여 저급 언어로 변환, 컴파일러가 소스 코드 내에서 오류를 발견하면 컴파일 실패. 컴파일러를 통하여 저급 언어로 변환된 코드는 목적 코드라 함
- 인터프리트 : 소스 전체가 변하는 컴파일 언어와 달리 인터프리터 언어는 소스 코드를 한 줄씩 차례로 실행. 한 줄씩 실행하기 때문에 N번째 줄에 문법 오류가 있다면, N-1줄 까지는 올바르게 수행

## 3.2 명령어의 구조

**명령어**는 연산코드와 오퍼랜드로 구성

- **연산코드** : 명령어가 수행할 연산 (연산자)
- **오퍼랜드** : 연산에 사용할 데이터, 연산에 사용할 데이터가 저장된 위치 (피연산자)

연산코드가 담기는 영역을 **연산코드 필드**, 오퍼랜드가 담기는 영역을 **오퍼랜드 필드**라 함

오퍼랜드 필드에는 숫자나 문자와 같이 연산에 사용할 데ㅣ터를 직접 명시하기 보다는, 많은 경우 연산에 사용할 데이터가 저장된 위치, 즉 메모리 주소나 레지스터 이름을 담음 → 주소 필드라고도함

오퍼랜드의 개수에 따라 0-주소 명령어, 1-주소 명령어, 2-주소 명령어, 3-주소 명령어로 나눔

연산코드의 유형은 크게 4가지

- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

대표적 연산 코드

- 데이터 전송
    - MOVE : 데이터를 옮겨라
    - STORE : 메모리에 저장하라
    - LOAD (FETCH) : 메모리에서 CPU로 데이터를 가져와라
    - PUSH : 스택에 데이터를 저장하라
    - POP : 스택의 최상단 데이터를 가져와라
- 산술/논리 연산
    - ADD/SUBTRACT/MULTIPLY/DIVIDE : 덧셈/뺄셈/곱셈/나눗셈 수행
    - INCREMENT/DECREMENT: 오퍼랜드에 1을 더하라/빼라
    - AND/OR/NOT : AND/OR/NOT 연산 수행
    - COMPARE : 두 개의 숫자 또는 TRUE/FALSE 값 비교
- 제어 흐름 변경
    - JUMP : 특정 주소로 실행 순서 변경
    - CONDITIONAL JUMP : 조건에 부합할 때 특정 주소로 실행 순서 변경
    - HALT : 프로그램의 실행을 중지
    - CALL : 되돌아올 주소를 저장한 채 특정 주소로 실행 순서를 옮겨라
    - RETURN : CALL을 호출할 때 저장했던 주소로 돌아가라
- 입출력 제어
    - READ (INPUT) : 특정 입출력 장치로부터 데이터를 읽어라
    - WRITE (OUTPUT) : 특정 입출력 장치로 데이터를 써라
    - START IO : 입출력 장치를 시작
    - TEST IO : 입출력 장치의 상태를 확인

주소 지정 방식

명령어의 길이 때문에 오퍼랜드 필드의 공간 할당이 줄어들기 때문에 오퍼랜드 필드에 메모리나 레지스터의 주소를 담음→ 연산의 대상이 되는 데이터가 저장된 위치를 **유효 주소** 라 한다

- 즉시 주소 지정 방식 : 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 설명할 다른 방식들보다 빠름
- 직접 주소 지정 방식 : 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식, 데이터의 크기는 크지만 여전히 유효 주소를 표현할 수 있는 범위가 연산 코드의 비트 수 만큼 줄음
- 간접 주소 지정 방식 : 유효 주소의 주소를 오퍼랜드 필드에 명시, 두 번의 메모리 접근이 필요하기 때문에 일반적으로 느림
- 레지스터 주소 지정 방식 : 직접 주소 지정방식과 비슷하게 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시. 메모리에 접근하는 것보다 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르기 때문 → 표현할 수 있는 레지스터 크기에 제한이 생길 수 있음
- 레지스터 간접 주소 지정 방식 : 메모리에 접근하는 횟수가 한 번으로 줄고, 레지스터에 접근하는 것이 메모리에 접근하는 것보다 빠르기 때문에 간접 주소 지정 방식보다 빠름